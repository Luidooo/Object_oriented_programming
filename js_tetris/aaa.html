<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris</title>
  <style>
    canvas {
      border: 1px solid #000;
      margin: 20px;
    }
  </style>
</head>
<body>

  <canvas id="tetrisCanvas" width="300" height="600"></canvas>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('tetrisCanvas');
      const context = canvas.getContext('2d');
      
      const ROWS = 20;
      const COLUMNS = 10;
      const BLOCK_SIZE = 30;

      class TetrisBlock {
        constructor(color) {
          this.color = color;
          this.shape = [
            [1, 1, 1],
            [0, 1, 0],
          ];
          this.x = 0;
          this.y = 0;
        }

        draw() {
          context.fillStyle = this.color;
          for (let row = 0; row < this.shape.length; row++) {
            for (let col = 0; col < this.shape[row].length; col++) {
              if (this.shape[row][col]) {
                const blockX = (this.x + col) * BLOCK_SIZE;
                const blockY = (this.y + row) * BLOCK_SIZE;
                context.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
              }
            }
          }
        }
      }

      class TetrisBoard {
        constructor() {
          this.grid = Array.from({ length: ROWS }, () => Array(COLUMNS).fill(null));
        }

        draw() {
          this.grid.forEach((row, rowIndex) => {
            row.forEach((color, colIndex) => {
              if (color) {
                context.fillStyle = color;
                context.fillRect(colIndex * BLOCK_SIZE, rowIndex * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
              }
            });
          });
        }

        isCollision(block) {
          for (let row = 0; row < block.shape.length; row++) {
            for (let col = 0; col < block.shape[row].length; col++) {
              if (
                block.shape[row][col] &&
                (this.grid[block.y + row] && this.grid[block.y + row][block.x + col]) !== undefined
              ) {
                return true;
              }
            }
          }
          return false;
        }

        placeBlock(block) {
          for (let row = 0; row < block.shape.length; row++) {
            for (let col = 0; col < block.shape[row].length; col++) {
              if (block.shape[row][col]) {
                this.grid[block.y + row][block.x + col] = block.color;
              }
            }
          }
        }

        clearLines() {
          for (let row = ROWS - 1; row >= 0; row--) {
            if (this.grid[row].every(cell => cell !== null)) {
              this.grid.splice(row, 1);
              this.grid.unshift(Array(COLUMNS).fill(null));
            }
          }
        }
      }

      class TetrisGame {
        constructor(canvas, context) {
          this.canvas = canvas;
          this.context = context;
          this.board = new TetrisBoard();
          this.currentBlock = this.spawnBlock();
          this.score = 0;
          this.gameOver = false;
        }

        spawnBlock() {
          const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
          const randomColor = colors[Math.floor(Math.random() * colors.length)];
          return new TetrisBlock(randomColor);
        }

        draw() {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.board.draw();
          this.currentBlock.draw();
        }

        moveDown() {
          this.currentBlock.y++;
          if (this.board.isCollision(this.currentBlock)) {
            this.currentBlock.y--;
            this.board.placeBlock(this.currentBlock);
            this.board.clearLines();
            this.currentBlock = this.spawnBlock();
            if (this.board.isCollision(this.currentBlock)) {
              this.gameOver = true;
            }
          }
        }

        moveLeft() {
          this.currentBlock.x--;
          if (this.board.isCollision(this.currentBlock)) {
            this.currentBlock.x++;
          }
        }

        moveRight() {
          this.currentBlock.x++;
          if (this.board.isCollision(this.currentBlock)) {
            this.currentBlock.x--;
          }
        }

        rotate() {
          const originalShape = this.currentBlock.shape;
          const rotatedShape = originalShape[0].map((_, i) => originalShape.map(row => row[i])).reverse();
          const tempBlock = { ...this.currentBlock, shape: rotatedShape };

          if (!this.board.isCollision(tempBlock)) {
            this.currentBlock.shape = rotatedShape;
          }
        }

        start() {
          this.intervalId = setInterval(() => {
            this.draw();
            this.moveDown();
            if (this.gameOver) {
              clearInterval(this.intervalId);
              alert('Game Over! Your score: ' + this.score);
            }
          }, 500);

          document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft') {
              this.moveLeft();
            } else if (event.key === 'ArrowRight') {
              this.moveRight();
            } else if (event.key === 'ArrowDown') {
              this.moveDown();
            } else if (event.key === 'ArrowUp') {
              this.rotate();
            }
          });
        }
      }

      const game = new TetrisGame(canvas, context);
      game.start();
    });
  </script>
</body>
</html>
